
---
title: "Effective Modern C++"
date: 
draft: true
---

* [Understand type deduction](/effectives/emcpp/it1/)
* [Understand auto type deduction](/effectives/emcpp/it2/)
* [Understand decltype](/effectives/emcpp/it3/)
* [Know how to view deduced types](/effectives/emcpp/it4/)
* [Prefer auto to explicit type declarations](/effectives/emcpp/it5/)
* [Use the explicitly typed initializer idiom when auto deduces undesired types](/effectives/emcpp/it6/)
* [Item 7: distinguish between () and {} when creating objects](/effectives/emcpp/it7/)
* [Item 8: prefer nullptr to 0 and NULL](/effectives/emcpp/it8/)
* [Item 9: prefer alias declarations to `typedefs`](/effectives/emcpp/it9/)
* [Item 10: prefer scoped enums to unscoped enums](/effectives/emcpp/it10/)
* [Item 11: prefer deleted functions to private undefined ones](/effectives/emcpp/it11/)
* [Item 12: declare overriding functions `override`](/effectives/emcpp/it12/)
* [Item 13: prefer `const_iterator`s to `iterator`s](/effectives/emcpp/it13/)
* [Item 14: declare functions `noexcept` if they won't emit exceptions](/effectives/emcpp/it14/)
* [Item 15: use `constexpr` whenever possible](/effectives/emcpp/it15/)
* [Item 16: make `const` member functions thread safe](/effectives/emcpp/it16/)
* [Item 17: understand special member function generation](/effectives/emcpp/it17/)
* [Item 18: use `std::unique_ptr` for exclusive-ownership resource management](/effectives/emcpp/it18/)
* [Item 19: use `std::shared_ptr` for shared-ownership resource management](/effectives/emcpp/it19/)
* [Item 20: use `std::weak_ptr` for `std::shared_ptr` like pointers that can dangle](/effectives/emcpp/it20/)
* [Item 21: prefer `std::make_unique` and `std::make_shared` to direct use of new](/effectives/emcpp/it21/)
* [Item 22: when using the pimpl idiom, define special member functions in the implementation file](/effectives/emcpp/it22/)
* [Item 23: understand `std::move` and `std::forward`](/effectives/emcpp/it23/)
* [Itemm 24: distinguish universal references from rvalue references](/effectives/emcpp/it24/)
* [Itemm 25: use `std::move` on rvalue references, `std::forward` on universal references](/effectives/emcpp/it25/)
* [Item 26: avoid overloading on universal references](/effectives/emcpp/it26/)
* [Item 27: familiarize yourself with alternatives to overloading on universal references](/effectives/emcpp/it27/)
* [Item 28: understand reference collapsing](/effectives/emcpp/it28/)
* [Assume that move operations are not present, not cheap, and not used](/effectives/emcpp/it29/)
* [Familiarize yourself with perfect forwarding failure cases](/effectives/emcpp/it30/)
* [Avoid default capture modes](/effectives/emcpp/it31/)
* [Use init capture to move objects into closures](/effectives/emcpp/it32/)
* [Use decltype on auto&& parameters to std::forward them](/effectives/emcpp/it33/)
* [Prefer lambdas to std::bind](/effectives/emcpp/it34/)
* [Prefer task-based programming to thread-based](/effectives/emcpp/it35/)
* [Specify std::launch::async if asynchronicity is essential](/effectives/emcpp/it36/)
* [Make std::threads unjoinable on all paths](/effectives/emcpp/it37/)
* [Be aware of varying thread handle destructor behavior](/effectives/emcpp/it38/)
* [Consider void futures for one-shot event communication](/effectives/emcpp/it39/)
* [Use std::atomic for concurrency, volatile for special memory](/effectives/emcpp/it40/)
* [Consider pass-by-value for copyable parameters that are cheap to move and always copied](/effectives/emcpp/it41/)
* [Consider emplacement instead of insertion](/effectives/emcpp/it42/)
