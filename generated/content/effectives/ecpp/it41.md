# Never redefine an inherited non-virtual function

Consider this code,
```cpp
class B {
public:
  void mf();
  ...
};
class D: public B { ... };

D x;                              // x is an object of type D

// you'd be quite surprised if the following two behave differently
B *pB = &x;                       // get pointer to x
pB->mf();                         // call mf through pointer

D *pD = &x;                       // get pointer to x
pD->mf();                         // call mf through pointer
```
How can these two differ?
They differ if `mf` is a non virtual function in `B` but redefined in `D`.

Like this
```cpp
class D: public B {
public:
  void mf();                      // hides B::mf; see Item 33
  ...
};
pB->mf();                         // calls B::mf
pD->mf();                         // calls D::mf
```
Reasoning for this is that non-virtual functions are statically bound, decided at compile time according to the type the pointer points to.

This kind of behavior is undesirable in that an object may behave as `B` or `D` which is decided by compile-time type as opposed to what the object really is.
References demonstrate similar behaviors as pointers.

What's more, item 34 described declaring a non-virtual function in base class conveys the idea that the function is invariant over specialization for that class.
Now if `D` redefines this function, there is a contradiction in the design.

This echos with item 7's declare dtors virtual in base classes: if they are not virtual, you'll hide base classes's dtor.
And should an object of the derived type be referred to using pointer to base type, only the base part will be dtor'ed afterwards.

**Takeaways**
* Never redefine an inherited non-virtual function


Snippet:
```cpp
// template_instiation.m.cpp
#include <iostream>
#include <string>
#include <memory>

// demonstrates implicit interface and compile time polymorphism in template
// instantiation

template<typename T>
void largerThanTen(T& w) {
  if (w.size() > 10) {
    std::cout << "larger than 10\n";
  } else {
    std::cout << "no larger than 10\n";
  }
}

class C3 {};

class C4 {};

class C2 {
public:
  C2() = default;
  C2(const C3&) {}
  // implicit conversion from C3 to C2

  C4 size() const { return C4(); }
};

class C5 {
public:
  C5() = default;
  C5(const C4&) {}
  // implicit conversion from C4 to C5
};

bool operator>(const C5& lhs, double rhs) {
  return true;
}

int main() {
  C2 obj;
  // using C3 here won't work, as compiler expects the implicit interface to
  // directly contain a call 'size()', rather than anything that this type can
  // implicitly convert to contains a call 'size()'
  largerThanTen(obj);
  return 0;
}

```
