# ## To recap

We introduced the following alternatives to public virtual methods:
* NVI idiom (private virtual being called into by public non-virtual)
* Holding a function pointer data member (per object customization allowed but restricted to working with common parts)
* Holding a `std::function` data member (similar with above but more flexibility in what can be given)
* Holding a `HealthCalcFunc` pointer data member (full fledged `Strategy` pattern where `HealthCalcFunc` can be inherited to customize per object calc behavior)

There are lots of alternatives in OO design, explore them often.

**Takeaways**
* Alternatives to virtual functions include the NVI idiom and various forms of the Strategy design pattern. The NVI idiom is itself an example of the Template Method design pattern
* A disadvantage of moving functionality from a member function to a function outside the class is that the non-member function lacks access to the class's non-public members
* `std::function` objects act like generalized function pointers. Such objects support all callable entities compatible with a given target signature


Snippet:
```cpp
// multiple_inheritance.m.cpp
#include <iostream>
#include <string>
#include <memory>

// demonstrates a case where arguably multiple inheritance is useful: inherit
// an interface from a class, and implementation from another (because we want
// to override its virtual functions)

class IPerson {                            // this class specifies the
public:                                    // interface to be implemented
  virtual ~IPerson() = default;

  virtual std::string name() const = 0;
}; 

class PersonInfo {                         // this class has functions
public:                                    // useful in implementing
                                           // the IPerson interface
  virtual ~PersonInfo() = default;

  virtual const char * theName() const {
    std::cout << valueDelimOpen() << "theName called"
              << valueDelimClose() << "\n";
    return "theName";
  }

  virtual const char * valueDelimOpen() const = 0;;
    // made abstract just for the sake
    // of demonstration

  virtual const char * valueDelimClose() const = 0;
};

class CPerson: public IPerson, private PersonInfo {
  // note use of MI: inherit interface from one class, implementation from
  // another (due to wanting to override some of the latter's virtual functions)
public:
  virtual std::string name() const                      // implementations
  { return PersonInfo::theName(); }                     // of the required
                                                        // IPerson member
                                                        // functions
private:                                                // redefinitions of
  const char * valueDelimOpen() const { return "["; }    // inherited virtual
  const char * valueDelimClose() const { return "]"; }   // delimiter
};                                                       // functions

int main() {
  std::unique_ptr<IPerson> pp = std::make_unique<CPerson>();
  pp->name();
  return 0;
}

```
