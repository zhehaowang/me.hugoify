# ## Strategy pattern via `std::function`

`std::function` can hold any callable entity (function pointer, function object, member function pointer, etc) whose signature is compatible with what's expected.
It would look something like this
```cpp
class GameCharacter;                                 // as before
int defaultHealthCalc(const GameCharacter& gc);      // as before

class GameCharacter {
public:
   // HealthCalcFunc is any callable entity that can be called with
   // anything compatible with a GameCharacter and that returns anything
   // compatible with an int; see below for details
   typedef std::function<int (const GameCharacter&)> HealthCalcFunc;

   explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)
   : healthFunc(hcf)
   {}

   int healthValue() const
   { return healthFunc(*this);   }

   ...

private:
  HealthCalcFunc healthFunc;
};
```
In this case, by compatible we mean the `std::function` can contain any functions whose parameter can implicitly convert to `const GameCharacter&` and return value can implicitly convert to `int`.

The difference with the function pointer approach is mininal, except that the client now has slightly more flexibility.
```cpp
short calcHealth(const GameCharacter&);          // health calculation
                                                 // function; note
                                                 // non-int return type

struct HealthCalculator {                        // class for health
  { ... }                                        // objects
};

class GameLevel {
public:
  float health(const GameCharacter&) const;      // health calculation
  ...                                            // mem function; note
};                                               // non-int return type


class EvilBadGuy : public GameCharacter {         // as before
  ...
};

class EyeCandyCharacter : public GameCharacter {  // another character
  ...                                             // type; assume same
};                                                // constructor as
                                                  // EvilBadGuy

EvilBadGuy ebg1(calcHealth);                      // character using a
                                                  // health calculation
                                                  // function

EyeCandyCharacter ecc1(HealthCalculator());       // character using a
                                                  // health calculation
                                                  // function object

GameLevel currentLevel;
...
EvilBadGuy ebg2(                                  // character using a
  std::bind(&GameLevel::health,                   // health calculation
          currentLevel,                           // member function;
          std::placeholders::_1_1)                // see below for details
);
```
`std::function` offers a lots of flexibility in the form of what can be given.
For example, the `std::bind` allows you to specify a particular function (in this case a member function with 2 parameters, first one being an implicit `this` pointer) to call, and adapt that to the number of parameters expected by the `std::function` object.


