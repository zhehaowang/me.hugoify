# Use private inheritance judiciously

Let's look at a private inheritance example
```cpp
class Person { ... };
class Student: private Person { ... };     // inheritance is now private

void eat(const Person& p);                 // anyone can eat

void study(const Student& s);              // only students study

Person p;                                  // p is a Person
Student s;                                 // s is a Student

eat(p);                                    // fine, p is a Person

eat(s);                                    // error! a Student isn't a Person
```

How does private inheritance behave?
* Compilers will generally not convert a derived class object into a base class object.
* Members inherited from a private base class become private members of the derived class, even if they were protected or public in the base class.

What does private inheritance mean?
It means is-implemented-in-terms-of. You do so because you want the derived to take advantage of some of the features available in the base, not because of there is any conceptual relationship between objects of the base and the derived.
As such, private inheritance is an implementation technique, and means nothing during software design.

Using the terms from Item 34, private inheritance means that implementation only should be inherited; interface should be ignored.

Item 38 suggests composition also can mean "is-implemented-in-terms-of", what to choose between the two?
Use composition whenever you can, and use private inheritance only when you must.

When must you?
Primarily when protected members and/or virtual functions enter the picture.

Let's say we have a `Widget` class and we now want to keep track of how many times each member function is called.
Suppose we already have this `Timer` class
```cpp
class Timer {
public:
  explicit Timer(int tickFrequency);
  virtual void onTick() const;          // automatically called for each tick
  ...
};
```
`Timer` can be configured to tick with whatever frequency we need, and on each tick, it calls a virtual function.
We can redefine the virtual function so that it examines the current state of the `Widget` world.

In order for `Widget` to redefine a virtual function in `Timer`, `Widget` must inherit from `Timer`, but public inheritance is not appropriate in this case. (not is-a, encourages misuses)

We then have
```cpp
class Widget: private Timer {
private:
  virtual void onTick() const;           // look at Widget usage data, etc.
  ...
};
```
Making `onTick` to private to not expose to client (mis)usage of this implementation detail.

This is a nice design, but achievable without private inheritance: make a Widget that publicly inherit from `Timer`, redefine `Timer` there, and put an object of that type inside `Widget`.
Like this
```cpp
class Widget {
private:
  class WidgetTimer: public Timer {
  public:
    virtual void onTick() const;
    ...
  };   // nested within Widget
  WidgetTimer timer;
  ...
};
```
This may seem more complicated, but two reasons you might want to go with this:
* You might want to allow `Widget` to be derived from, but you might want to prevent derived classes from redefining `onTick` (like `final` in Java. If `Widget` inherits from `Timer`, that's not possible, not even if the inheritance is private
* You might want to minimize `Widget`'s compilation dependencies. If `Widget` inherits from `Timer`, `Timer`'s definition must be available when `Widget` is compiled, so `Widget` header has to be included. If `WidgetTimer` is moved out of `Widget` and `Widget` contains only a pointer to `WidgetTimer`, `Widget` can get by with a simple declaration for the `WidgetTimer` class

There is other very edgy case where private inheritance might save space: when you are dealing with a class that has no data in it.
"Freestanding" empty class in C++ has non-0 size. If you do this
```cpp
class Empty {};                      // has no data, so objects should
                                     // use no memory
class HoldsAnInt {                   // should need only space for an int
private:
  int x;
  Empty e;                           // should require no memory
};
```
You'll find that `sizeof(HoldsOfInt) > sizeof(int)`.
A `char` is usually silently inserted into `Empty`, and compilers add padding to `HoldsAnInt`.

Now if we have a `Empty` as base, and `HoldsAnInt` derive from it, you are almost sure to find that `sizeof(HoldsAnInt) == sizeof(int)`.
An object of `HoldsAnInt` is not freestanding, and the base part of it needn't have a non-0 size.
This is known as empty base optimization (EBO). EBO is generally only viable under single inheritance.

In practice, empty classes aren't truly empty.
They never have non-static data members, they often contain `typedef`s, `enum`s, static data members, or non-virtual functions.
The STL has many such. `unary_function`, `binary_function` are too.

But let's go back to the basics, both private inheritance and composition mean is-implemented-in-terms-of, but composition is easier to understand, so use it whenever you can.

**Takeaways**
* Private inheritance means is-implemented-in-terms of. It's usually inferior to composition, but it makes sense when a derived class needs access to protected base class members or needs to redefine inherited virtual functions
* Unlike composition, private inheritance can enable the empty base optimization. This can be important for library developers who strive to minimize object sizes


Snippet:
```cpp
// factor_parameter_independent_code_out_of_templates.m.cpp
#include <iostream>
#include <string>
#include <memory>

// demonstrates cases where one can / should factor parameter code out of
// templates to avoid code bloat, by parameterizing a non-type parameter
// required to instantiate a template

// bloat version
template<typename T,           // template for n x n matrices of
         std::size_t n>        // objects of type T; a non-type parameter
class SquareMatrixBloat {      // on the size_t parameter
public:
  void invert() {              // invert the matrix in place
    // some business logic
    std::cout << "SquareMatrixBloat: invert\n";
  }
};

// unbloat version
template<typename T>
class SquareMatrixBase {
protected:
  SquareMatrixBase(std::size_t n, T *pMem)     // store matrix size and a
  : size(n), pData(pMem) {}                    // ptr to matrix values

  void setDataPtr(T *ptr) { pData = ptr; }     // reassign pData

  void invert(std::size_t matrixSize) {        // invert matrix of the given
    // some business logic                     // size. Work with 'pData' and
    std::cout << "SquareMatrixBase: invert "   // 'size'
              << matrixSize << "\n";
  }
private:
  std::size_t size;                            // size of matrix
  T *pData;                                    // pointer to matrix values
};

template<typename T, std::size_t n>
class SquareMatrix: private SquareMatrixBase<T> {
private:
  using SquareMatrixBase<T>::invert; // avoid hiding base version of invert,
                                     // item 33
public:
  SquareMatrix()                             // send matrix size and
  : SquareMatrixBase<T>(n, data) {}          // data ptr to base class
  // derived class is in charge actual allocation, but gives a pointer of its
  // data to the base so that invert knows what to work with

  void invert() { this->invert(n); }; // does this violate item 37? arguably not
                                      // as the inheritance relationship is not
                                      // public, you can't assign SquareMatrix*
                                      // to SquareMatrixBase* and call invert on
                                      // the same pointer and expect different
                                      // behaviors due to static binding.
                                      // SquareMatrixBase is not meant to be
                                      // exposed, by this design.
private:
  T data[n*n];
};


int main() {
  SquareMatrixBloat<double, 5> smb1;
  smb1.invert();

  SquareMatrixBloat<double, 10> smb2;
  smb2.invert();

  // business logic in SquareMatrixBloat::invert will be generated twice

  SquareMatrix<double, 5> sm1;
  sm1.invert();

  SquareMatrix<double, 10> sm2;
  sm2.invert();

  // business logic in SquareMatrixBase::invert will not be generated twice

  // the parameterized version may run slower: e.g. less opportunity for
  // compile-time optimization such as constant propagation.
  // but it also results in smaller binary size, which may better leverage
  // instruction cache locality.

  return 0;
}

```
