# ## The strategy pattern via function pointers

A more dramatic change suggests `healthValue` need not be part of a `GameCharacter` class. Like this.
```cpp
class GameCharacter;                               // forward declaration

// function for the default health calculation algorithm
int defaultHealthCalc(const GameCharacter& gc);

class GameCharacter {
public:
  typedef int (*HealthCalcFunc)(const GameCharacter&);

  explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)
  : healthFunc(hcf)
  {}

  int healthValue() const
  { return healthFunc(*this); }

  ...

private:
  HealthCalcFunc healthFunc;
};
```
This can be seen as a strategy design pattern: it offers the flexibility of having different `healthValue` calculation for different instances of characters (not just different types of characters), also `healthValue` can be changed at runtime.

On the other hand, `healthValue` not being a member means it does not have access to internal parts of the object whose health it's calculating, and this becomes an issue when not all the info needed to calculated health is public.
As a general rule the only way to work around this is to weaken encapsulation: either by declaring the method a friend, or expose public getters to parts that it would otherwise have kept hidden.


