# ## Non virtual interface idiom

Let's begin with the interesting school of thought that virtual functions should almost always be private.
Adherents to this school would make `healthValue` a non-virtual public method that calls into a virtual private method `doHealthValue`, like this
```cpp
class GameCharacter {
public:
  int healthValue() const               // derived classes do not redefine
  {                                     // this — see Item 36

    ...                                 // do "before" stuff — see below

    int retVal = doHealthValue();       // do the real work

    ...                                 // do "after" stuff — see below

    return retVal;
  }
  ...

private:
  virtual int doHealthValue() const     // derived classes may redefine this
  {
    ...                                 // default algorithm for calculating
  }                                     // character's health
};
```
This is called NVI idiom (non-virtual interface), for having a non-virtual public function call a private virtual method.
A particular manifestation of a more general pattern called Template Method (which has nothing to do with C++ templates).

An advantage of this comes from the "do before stuff" and "do after stuff" comments: some code can be guaranteed to be executed before and after the virtual function does the work, e.g. context setup and teardown (lock a mutex, making a log entry, making sure invariants are satisfied).

NVI means clients redefine something private, something they can't call!
But there is no design contradiction there: redefining a virtual function specifies how something is to be done. Calling a virtual function specifies when it will be done. These concerns are independent.
NVI opens up the how, but not the when.
The NVI idiom does not mandate the function to be overridden is private: protected is also common should its functionality be exposed to derived classes.


